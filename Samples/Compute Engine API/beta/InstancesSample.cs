// Copyright 2017 DAIMTO ([Linda Lawton](https://twitter.com/LindaLawtonDK)) :  [www.daimto.com](http://www.daimto.com/)
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by DAIMTO-Google-apis-Sample-generator 1.0.0
//     Template File Name:  methodTemplate.tt
//     Build date: 2017-10-08
//     C# generater version: 1.0.0
//     
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------  
// About 
// 
// Unoffical sample for the Compute beta API for C#. 
// This sample is designed to be used with the Google .Net client library. (https://github.com/google/google-api-dotnet-client)
// 
// API Description: Creates and runs virtual machines on Google Cloud Platform.
// API Documentation Link https://developers.google.com/compute/docs/reference/latest/
//
// Discovery Doc  https://www.googleapis.com/discovery/v1/apis/Compute/beta/rest
//
//------------------------------------------------------------------------------
// Installation
//
// This sample code uses the Google .Net client library (https://github.com/google/google-api-dotnet-client)
//
// NuGet package:
//
// Location: https://www.nuget.org/packages/Google.Apis.Compute.beta/ 
// Install Command: PM>  Install-Package Google.Apis.Compute.beta
//
//------------------------------------------------------------------------------  
using Google.Apis.Compute.beta;
using Google.Apis.Compute.beta.Data;
using System;

namespace GoogleSamplecSharpSample.Computebeta.Methods
{
  
    public static class InstancesSample
    {

        public class InstancesAddAccessConfigOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Adds an access config to an instance's network interface. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/addAccessConfig
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name for this request.</param>
        /// <param name="networkInterface">The name of the network interface to add to this instance.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation AddAccessConfig(ComputeService service, string project, string zone, string instance, string networkInterface, AccessConfig body, InstancesAddAccessConfigOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (networkInterface == null)
                    throw new ArgumentNullException(networkInterface);

                // Building the initial request.
                var request = service.Instances.AddAccessConfig(body, project, zone, instance, networkInterface);

                // Applying optional parameters to the request.                
                request = (InstancesResource.AddAccessConfigRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.AddAccessConfig failed.", ex);
            }
        }
        public class InstancesAggregatedListOptionalParms
        {
            /// Sets a filter {expression} for filtering listed resources. Your {expression} must be in the format: field_name comparison_string literal_string.The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.For example, to filter for instances that do not have a name of example-instance, you would use name ne example-instance.You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
            public string Filter { get; set; }  
            /// The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
            public int? MaxResults { get; set; }  
            /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.Currently, only sorting by name or creationTimestamp desc is supported.
            public string OrderBy { get; set; }  
            /// Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
            public string PageToken { get; set; }  
        
        }
 
        /// <summary>
        /// Retrieves aggregated list of instances. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/aggregatedList
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>InstanceAggregatedListResponse</returns>
        public static InstanceAggregatedList AggregatedList(ComputeService service, string project, InstancesAggregatedListOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);

                // Building the initial request.
                var request = service.Instances.AggregatedList(project);

                // Applying optional parameters to the request.                
                request = (InstancesResource.AggregatedListRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.AggregatedList failed.", ex);
            }
        }
        public class InstancesAttachDiskOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Attaches an existing Disk resource to an instance. You must first create the disk before you can attach it. It is not possible to create and attach a disk at the same time. For more information, read Adding a persistent disk to your instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/attachDisk
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name for this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation AttachDisk(ComputeService service, string project, string zone, string instance, AttachedDisk body, InstancesAttachDiskOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.AttachDisk(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.AttachDiskRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.AttachDisk failed.", ex);
            }
        }
        public class InstancesDeleteOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Deletes the specified Instance resource. For more information, see Stopping or Deleting an Instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/delete
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to delete.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation Delete(ComputeService service, string project, string zone, string instance, InstancesDeleteOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.Delete(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.DeleteRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Delete failed.", ex);
            }
        }
        public class InstancesDeleteAccessConfigOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Deletes an access config from an instance's network interface. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/deleteAccessConfig
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name for this request.</param>
        /// <param name="accessConfig">The name of the access config to delete.</param>
        /// <param name="networkInterface">The name of the network interface.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation DeleteAccessConfig(ComputeService service, string project, string zone, string instance, string accessConfig, string networkInterface, InstancesDeleteAccessConfigOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (accessConfig == null)
                    throw new ArgumentNullException(accessConfig);
                if (networkInterface == null)
                    throw new ArgumentNullException(networkInterface);

                // Building the initial request.
                var request = service.Instances.DeleteAccessConfig(project, zone, instance, accessConfig, networkInterface);

                // Applying optional parameters to the request.                
                request = (InstancesResource.DeleteAccessConfigRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.DeleteAccessConfig failed.", ex);
            }
        }
        public class InstancesDetachDiskOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Detaches a disk from an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/detachDisk
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Instance name.</param>
        /// <param name="deviceName">Disk device name to detach.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation DetachDisk(ComputeService service, string project, string zone, string instance, string deviceName, InstancesDetachDiskOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (deviceName == null)
                    throw new ArgumentNullException(deviceName);

                // Building the initial request.
                var request = service.Instances.DetachDisk(project, zone, instance, deviceName);

                // Applying optional parameters to the request.                
                request = (InstancesResource.DetachDiskRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.DetachDisk failed.", ex);
            }
        }

        /// <summary>
        /// Returns the specified Instance resource. Get a list of available instances by making a list() request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/get
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to return.</param>
        /// <returns>InstanceResponse</returns>
        public static Instance Get(ComputeService service, string project, string zone, string instance)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Make the request.
                return service.Instances.Get(project, zone, instance).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Get failed.", ex);
            }
        }
        public class InstancesGetSerialPortOutputOptionalParms
        {
            /// Specifies which COM or serial port to retrieve data from.
            public int? Port { get; set; }  
            /// Returns output starting from a specific byte position. Use this to page through output when the output is too large to return in a single request. For the initial request, leave this field unspecified. For subsequent calls, this field should be set to the next value returned in the previous call.
            public string Start { get; set; }  
        
        }
 
        /// <summary>
        /// Returns the specified instance's serial port output. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/getSerialPortOutput
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>SerialPortOutputResponse</returns>
        public static SerialPortOutput GetSerialPortOutput(ComputeService service, string project, string zone, string instance, InstancesGetSerialPortOutputOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.GetSerialPortOutput(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.GetSerialPortOutputRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.GetSerialPortOutput failed.", ex);
            }
        }
        public class InstancesInsertOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
            /// Specifies instance template to create the instance.This field is optional. It can be a full or partial URL. For example, the following are all valid URLs to an instance template:  - https://www.googleapis.com/compute/v1/projects/project/global/global/instanceTemplates/instanceTemplate - projects/project/global/global/instanceTemplates/instanceTemplate - global/instancesTemplates/instanceTemplate
            public string SourceInstanceTemplate { get; set; }  
        
        }
 
        /// <summary>
        /// Creates an instance resource in the specified project using the data included in the request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/insert
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation Insert(ComputeService service, string project, string zone, Instance body, InstancesInsertOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);

                // Building the initial request.
                var request = service.Instances.Insert(body, project, zone);

                // Applying optional parameters to the request.                
                request = (InstancesResource.InsertRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Insert failed.", ex);
            }
        }
        public class InstancesListOptionalParms
        {
            /// Sets a filter {expression} for filtering listed resources. Your {expression} must be in the format: field_name comparison_string literal_string.The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.For example, to filter for instances that do not have a name of example-instance, you would use name ne example-instance.You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
            public string Filter { get; set; }  
            /// The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
            public int? MaxResults { get; set; }  
            /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.Currently, only sorting by name or creationTimestamp desc is supported.
            public string OrderBy { get; set; }  
            /// Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
            public string PageToken { get; set; }  
        
        }
 
        /// <summary>
        /// Retrieves the list of instances contained within the specified zone. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/list
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>InstanceListResponse</returns>
        public static InstanceList List(ComputeService service, string project, string zone, InstancesListOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);

                // Building the initial request.
                var request = service.Instances.List(project, zone);

                // Applying optional parameters to the request.                
                request = (InstancesResource.ListRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.List failed.", ex);
            }
        }
        public class InstancesListReferrersOptionalParms
        {
            /// Sets a filter {expression} for filtering listed resources. Your {expression} must be in the format: field_name comparison_string literal_string.The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.For example, to filter for instances that do not have a name of example-instance, you would use name ne example-instance.You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
            public string Filter { get; set; }  
            /// The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
            public int? MaxResults { get; set; }  
            /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.Currently, only sorting by name or creationTimestamp desc is supported.
            public string OrderBy { get; set; }  
            /// Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
            public string PageToken { get; set; }  
        
        }
 
        /// <summary>
        /// Retrieves the list of referrers to instances contained within the specified zone. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/listReferrers
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the target instance scoping this request, or '-' if the request should span over all instances in the container.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>InstanceListReferrersResponse</returns>
        public static InstanceListReferrers ListReferrers(ComputeService service, string project, string zone, string instance, InstancesListReferrersOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.ListReferrers(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.ListReferrersRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.ListReferrers failed.", ex);
            }
        }
        public class InstancesResetOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Performs a reset on the instance. For more information, see Resetting an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/reset
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation Reset(ComputeService service, string project, string zone, string instance, InstancesResetOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.Reset(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.ResetRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Reset failed.", ex);
            }
        }
        public class InstancesSetDiskAutoDeleteOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets the auto-delete flag for a disk attached to an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setDiskAutoDelete
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name.</param>
        /// <param name="autoDelete">Whether to auto-delete the disk when the instance is deleted.</param>
        /// <param name="deviceName">The device name of the disk to modify.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetDiskAutoDelete(ComputeService service, string project, string zone, string instance, bool? autoDelete, string deviceName, InstancesSetDiskAutoDeleteOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (autoDelete == null)
                    throw new ArgumentNullException(autoDelete);
                if (deviceName == null)
                    throw new ArgumentNullException(deviceName);

                // Building the initial request.
                var request = service.Instances.SetDiskAutoDelete(project, zone, instance, autoDelete, deviceName);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetDiskAutoDeleteRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetDiskAutoDelete failed.", ex);
            }
        }
        public class InstancesSetLabelsOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets labels on an instance. To learn more about labels, read the Labeling Resources documentation. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setLabels
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetLabels(ComputeService service, string project, string zone, string instance, InstancesSetLabelsRequest body, InstancesSetLabelsOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetLabels(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetLabelsRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetLabels failed.", ex);
            }
        }
        public class InstancesSetMachineResourcesOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Changes the number and/or type of accelerator for a stopped instance to the values specified in the request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setMachineResources
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetMachineResources(ComputeService service, string project, string zone, string instance, InstancesSetMachineResourcesRequest body, InstancesSetMachineResourcesOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetMachineResources(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetMachineResourcesRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetMachineResources failed.", ex);
            }
        }
        public class InstancesSetMachineTypeOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Changes the machine type for a stopped instance to the machine type specified in the request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setMachineType
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetMachineType(ComputeService service, string project, string zone, string instance, InstancesSetMachineTypeRequest body, InstancesSetMachineTypeOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetMachineType(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetMachineTypeRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetMachineType failed.", ex);
            }
        }
        public class InstancesSetMetadataOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets metadata for the specified instance to the data included in the request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setMetadata
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetMetadata(ComputeService service, string project, string zone, string instance, Metadata body, InstancesSetMetadataOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetMetadata(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetMetadataRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetMetadata failed.", ex);
            }
        }
        public class InstancesSetMinCpuPlatformOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Changes the minimum CPU platform that this instance should use. This method can only be called on a stopped instance. For more information, read Specifying a Minimum CPU Platform. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setMinCpuPlatform
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetMinCpuPlatform(ComputeService service, string project, string zone, string instance, InstancesSetMinCpuPlatformRequest body, InstancesSetMinCpuPlatformOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetMinCpuPlatform(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetMinCpuPlatformRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetMinCpuPlatform failed.", ex);
            }
        }
        public class InstancesSetSchedulingOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets an instance's scheduling options. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setScheduling
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Instance name.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetScheduling(ComputeService service, string project, string zone, string instance, Scheduling body, InstancesSetSchedulingOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetScheduling(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetSchedulingRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetScheduling failed.", ex);
            }
        }
        public class InstancesSetServiceAccountOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets the service account on the instance. For more information, read Changing the service account and access scopes for an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setServiceAccount
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to start.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetServiceAccount(ComputeService service, string project, string zone, string instance, InstancesSetServiceAccountRequest body, InstancesSetServiceAccountOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetServiceAccount(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetServiceAccountRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetServiceAccount failed.", ex);
            }
        }
        public class InstancesSetTagsOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Sets tags for the specified instance to the data included in the request. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/setTags
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance scoping this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation SetTags(ComputeService service, string project, string zone, string instance, Tags body, InstancesSetTagsOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.SetTags(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.SetTagsRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.SetTags failed.", ex);
            }
        }
        public class InstancesStartOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Starts an instance that was stopped using the using the instances().stop method. For more information, see Restart an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/start
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to start.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation Start(ComputeService service, string project, string zone, string instance, InstancesStartOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.Start(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.StartRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Start failed.", ex);
            }
        }
        public class InstancesStartWithEncryptionKeyOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Starts an instance that was stopped using the using the instances().stop method. For more information, see Restart an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/startWithEncryptionKey
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to start.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation StartWithEncryptionKey(ComputeService service, string project, string zone, string instance, InstancesStartWithEncryptionKeyRequest body, InstancesStartWithEncryptionKeyOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.StartWithEncryptionKey(body, project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.StartWithEncryptionKeyRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.StartWithEncryptionKey failed.", ex);
            }
        }
        public class InstancesStopOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Stops a running instance, shutting it down cleanly, and allows you to restart the instance at a later time. Stopped instances do not incur per-minute, virtual machine usage charges while they are stopped, but any resources that the virtual machine is using, such as persistent disks and static IP addresses, will continue to be charged until they are deleted. For more information, see Stopping an instance. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/stop
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">Name of the instance resource to stop.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation Stop(ComputeService service, string project, string zone, string instance, InstancesStopOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);

                // Building the initial request.
                var request = service.Instances.Stop(project, zone, instance);

                // Applying optional parameters to the request.                
                request = (InstancesResource.StopRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.Stop failed.", ex);
            }
        }

        /// <summary>
        /// Returns permissions that a caller has on the specified resource. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/testIamPermissions
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="resource">Name of the resource for this request.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <returns>TestPermissionsResponseResponse</returns>
        public static TestPermissionsResponse TestIamPermissions(ComputeService service, string project, string zone, string resource, TestPermissionsRequest body)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (resource == null)
                    throw new ArgumentNullException(resource);

                // Make the request.
                return service.Instances.TestIamPermissions(body, project, zone, resource).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.TestIamPermissions failed.", ex);
            }
        }
        public class InstancesUpdateAccessConfigOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Updates the specified access config from an instance's network interface with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/updateAccessConfig
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name for this request.</param>
        /// <param name="networkInterface">The name of the network interface where the access config is attached.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation UpdateAccessConfig(ComputeService service, string project, string zone, string instance, string networkInterface, AccessConfig body, InstancesUpdateAccessConfigOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (networkInterface == null)
                    throw new ArgumentNullException(networkInterface);

                // Building the initial request.
                var request = service.Instances.UpdateAccessConfig(body, project, zone, instance, networkInterface);

                // Applying optional parameters to the request.                
                request = (InstancesResource.UpdateAccessConfigRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.UpdateAccessConfig failed.", ex);
            }
        }
        public class InstancesUpdateNetworkInterfaceOptionalParms
        {
            /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
            public string RequestId { get; set; }  
        
        }
 
        /// <summary>
        /// Updates an instance's network interface. This method follows PATCH semantics. 
        /// Documentation https://developers.google.com/compute/beta/reference/instances/updateNetworkInterface
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated Compute service.</param>  
        /// <param name="project">Project ID for this request.</param>
        /// <param name="zone">The name of the zone for this request.</param>
        /// <param name="instance">The instance name for this request.</param>
        /// <param name="networkInterface">The name of the network interface to update.</param>
        /// <param name="body">A valid Compute beta body.</param>
        /// <param name="optional">Optional paramaters.</param>
        /// <returns>OperationResponse</returns>
        public static Operation UpdateNetworkInterface(ComputeService service, string project, string zone, string instance, string networkInterface, NetworkInterface body, InstancesUpdateNetworkInterfaceOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (project == null)
                    throw new ArgumentNullException(project);
                if (zone == null)
                    throw new ArgumentNullException(zone);
                if (instance == null)
                    throw new ArgumentNullException(instance);
                if (networkInterface == null)
                    throw new ArgumentNullException(networkInterface);

                // Building the initial request.
                var request = service.Instances.UpdateNetworkInterface(body, project, zone, instance, networkInterface);

                // Applying optional parameters to the request.                
                request = (InstancesResource.UpdateNetworkInterfaceRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Instances.UpdateNetworkInterface failed.", ex);
            }
        }
        
        }

        public static class SampleHelpers
        {

        /// <summary>
        /// Using reflection to apply optional parameters to the request.  
        /// 
        /// If the optonal parameters are null then we will just return the request as is.
        /// </summary>
        /// <param name="request">The request. </param>
        /// <param name="optional">The optional parameters. </param>
        /// <returns></returns>
        public static object ApplyOptionalParms(object request, object optional)
        {
            if (optional == null)
                return request;

            System.Reflection.PropertyInfo[] optionalProperties = (optional.GetType()).GetProperties();

            foreach (System.Reflection.PropertyInfo property in optionalProperties)
            {
                // Copy value from optional parms to the request.  They should have the same names and datatypes.
                System.Reflection.PropertyInfo piShared = (request.GetType()).GetProperty(property.Name);
				if (property.GetValue(optional, null) != null) // TODO Test that we do not add values for items that are null
					piShared.SetValue(request, property.GetValue(optional, null), null);
            }

            return request;
        }
    }
}